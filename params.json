{"name":"global","tagline":"44KB of Helpers: Http/Rest, Serialization/Deserialization, Extensions, IO, Email, Security and a light curl/wget like cli for windows users!","body":"## installation\r\n\r\ncouldn't be simpler. just reference **Global.dll** into your project and you're set to go.\r\n\r\n## usage\r\n\r\n### http\r\n\r\nnowdays apps are designed to be rest oriented. most of them expose http api's so consumers/users can take advange of their services and/or consume 3rd party http api's. global tries to tackle this problem by building a simple abstraction layer.\r\n\r\nbuilding the api url is one. normaly one has a base url like http://api.example.com/ to avoid repeating it on other urls. the relative url differs according to the tasks one wants to do, eg: **categories/** or **orders/1** or even **products/?filter.Name=Tea&filter.Price.lt=4.59**. instead of using string.Format or += use UrlBuilder fluent syntax:\r\n\r\n```csharp\r\nvar u = new UrlBuilder();\r\nvar url = u.BaseUrl(\"http://api.example.com/products/\")\r\n    .Parameters(p => p\r\n        .Add(\"filter.Name\", \"Tea\")\r\n        .Add(\"filter.Price.lt\", \"4.59\"))\r\n    .Build();\r\n```\r\n\r\nwhich would output: ```http://api.example.com/products/?filter.Name=Tea&filter.Price.lt=4.59```.\r\n\r\nanother feature when developing these kinds of apps is actually making the http request, serializing the payload and response into the appropriate format (json or xml). Here's an example of how easy it is to set up and configure the helper:\r\n\r\n```csharp\r\nvar http = new Http(u => u\r\n        .BaseUrl(\"http://www.google.com/\")\r\n        .Parameters(p => p\r\n            .Add(\"q\", \"Cute+Pictures+Of+Birds\")\r\n            .Add(\"hl\", \"en\")))\r\n    .SetContentType(\"text/html\")\r\n    .SetMethod(\"GET\")\r\n    .SetHeaders(h => h\r\n        .AddRequestHeader(\"CustomUserAgent\", \"Global User Agent\")\r\n        .AddRequestHeader(\"Accept\", \"application/xml\"));\r\n```\r\n\r\nas you can see, in the constructor you can use the UrlBuilder shown above.\r\nmost of the http settings are available through this helper. aside from the fluent syntax you can also set/ovewrite values using properties:\r\n\r\n```csharp\r\nhttp.ResponseEncoding = Encoding.UTF8;\r\nhttp.UserAgent = \"custom_user_agent\";\r\n```\r\n\r\nto actually make the request just do ```var response = http.DoRequest();``` to get the response in string format. but this is not the real scenario, normally we want to get the response already parsed into the desired object even if it comes in xml or json format. for example, if you have the following object:\r\n\r\n```csharp\r\nvar obj = new SampleObject\r\n{\r\n    Id = Guid.NewGuid(),\r\n    Name = \"André\",\r\n    AnotherObject = new SampleObject.SubObject\r\n    {\r\n        Age = 24,\r\n        Birthdate = DateTime.Now\r\n    }\r\n};\r\n```\r\n\r\nwhich is returned in xml format from a rest api. to get the response already serialized we can just call ```var sampleObject = http.DoRequest<SampleObject>(Format.Xml);```. and now we can access it as a normal SampleObject by calling it’s properties:\r\n\r\n```csharp\r\nConsole.WriteLine(\"{0} is {1} years old.\", \r\n    sampleObject.Name, \r\n    sampleObject.AnotherObject.Age);\r\n```\r\n\r\n### serialization\r\n\r\nyou already saw this in action in the previous section. but you can use it independently. consider the above SampleObject we've created. to convert that object into a json/xml file:\r\n\r\n```csharp\r\n// saved on disk as json\r\nDataContractSerializerHelper\r\n    .ToJsonFile(@\"C:\\serialized.json\", obj, Encoding.UTF8);\r\n \r\n// saved on disk as xml\r\nDataContractSerializerHelper\r\n    .ToXmlFile(@\"C:\\serialized.xml\", obj, Encoding.UTF8);\r\n```\r\n\r\nor you can convert it into a string:\r\n\r\n```csharp\r\n// saved on disk as json\r\nvar jsonString = DataContractSerializerHelper.ToJsonString(obj, Encoding.UTF8);\r\n \r\n// saved on disk as xml\r\nvar xmlString = DataContractSerializerHelper.ToXmlString(obj, Encoding.UTF8);\r\n```\r\n\r\nin other cases, it's necessary to read json/xml files stored on disk:\r\n\r\n```csharp\r\n// deserialize from a json file\r\nvar json = DataContractSerializerHelper\r\n    .FromJsonFile<SampleObject>(@\"C:\\serialized.json\", Encoding.UTF8);\r\n \r\n// deserialize from a xml file\r\nvar xml = DataContractSerializerHelper\r\n    .FromXmlFile<SampleObject>(@\"C:\\serialized.xml\");\r\n```\r\n\r\nthe same applies to strings:\r\n\r\n```csharp\r\n// deserialize from a json string\r\nvar json = DataContractSerializerHelper\r\n    .FromJsonString<SampleObject>(jsonString);\r\n \r\n// deserialize from a xml string\r\nvar xml = DataContractSerializerHelper\r\n    .FromXmlString<SampleObject>(xmlString);\r\n```\r\n\r\nthe above examples use the ```DataContractSerializer``` but there's also available the ```XmlSerializer```.\r\n\r\n### mail\r\n\r\nfor monitoring or reporting, mail is a main function in any application, big or small. and when doing it over and over we should have a way to do it in a very simple way. first, configure to whom to send mails:\r\n\r\n```csharp\r\n// Configure mails with Name and Email\r\nvar bcc = new Dictionary<string, string>\r\n    {\r\n        {\"Person\", \"person@mail.com\"},\r\n        {\"Another Person\",\"another.person@mail.com\"}\r\n    };\r\n// Or just the Emails\r\nvar cc = new List<string>\r\n    {\r\n        \"wow.another.person@anothermail.com\",\r\n        \"ok.another.person@anothermail.com\"\r\n    };\r\n```\r\n\r\nand using the fluent syntax configure other properties like SSL, Subject, etc and just send the email. \r\n\r\n```csharp\r\nvar mail = new Mail(\"smtp.gmail.com\", 587);\r\nmail.From(\"Andre Carrilho\", \"me@mymail.com\")\r\n    .To(to => to.Add(\"Andre Carrilho\", \"anotherme@mymail.com\"))\r\n    .Bcc(bcc => bcc.Add(bcc))\r\n    .Cc(cc => cc.Add(cc))\r\n    .IsBodyHtml(true)\r\n    .Body(\"Html <p style='color:blue;font-size:32px;'>content</p>.\")\r\n    .Subject(\"Testing Fluent MailHelper\")\r\n    .Credentials(\"someUser\", \"somePass\")\r\n    .Port(1234)\r\n    .Ssl(true)\r\n    .Send();\r\n```\r\n\r\nit is that simple!\r\n\r\n## an extra tidbit\r\n\r\neveryone loves wget/curl but unfortunately on windows, unless you're using cygwin or mysysgit, you're out of luck. that's why http.exe was born. to use got to the **requester** folder and issue the appropriate command, eg:\r\n\r\n```http.exe -u \"http://www.google.com/\" -ua \"My_User_Agent\" -m \"GET\" -ct -oc```\r\n\r\ntype ```http``` to learn all available arguments.","google":"UA-2519200-6","note":"Don't delete this file! It's used internally to help with page regeneration."}